################################################################################
全体の動作について
###############################################################################

windowsアプリケーションらしく、winmain(0x420240)の呼び出しから始まる。
で、芯のメッセージループ部は、0x42044f〜0x4204dc あたり。(Peekmessageでmessageがたまってなければ呼んでいる)
で、自機とか敵機とか弾とかは、
call 0x420770 -> call 0x418c40 , 0x418da0 で更新されている。
0x418c40 , 0x418da0 はどちらもタスクシステムの更新をやっていて、
0x418c40 + 77 で、

################################################################################
タスクシステムへの登録
###############################################################################
データの初期化や、タスクシステムへの登録は、0x417a70 で順番にやってる。
stagedata -> font -> 敵弾 -> 写真 -> 自機 -> 敵 -> pause -> bullet(LaserInf) の順でやってる。
で、各々のデータは、
{
	push    offset sub_4059C0
	mov     ecx, offset unk_4BE3C8
	call    sub_4190B0 (メンバ関数(この場合sub_4059C0)を登録)
}
{
	push    0Eh
	mov     ecx, [ebp+var_10]
	push    ecx
	mov     ecx, offset unk_4BE3C8
	call    sub_418A20  //or call sub_418B30 
	(ecxに入れられたunk_4BE3C8をクラスポインタとして、第一引数の呼び出しクラスを、第二引数の番号で紐付してタスクシステムに登録する)
	(sub_418A20  の場合、 (0x4be3c8 のチェインに登録され, sub_418C40 内から呼ばれる。) 
	また、 call sub_418B30 の場合、 (0x4be3c8 + 0x20 のチェインに登録され, 0x418da0内から呼ばれる。))
	(sub_418a20 は、moveのためのチェイン,sub_418B30は、描画のためのチェインぽい。)
}
で登録されている。
で、こんな感じで登録される
{ タスクシステムでチェイン状に登録されている構造体(size .. 20h) は、
	0x0 .. index number(byte) (紐付番号)
	0x2 .. 謎。未初期化時に &= 0xfffe されてる. また、 |= 1.
	0x4 .. 構造体特有の関数
	0x8 .. とりま0. 場合によっては初期化時にcallされるらしい。
	0xc .. とりま0
	0x10 .. 前の構造体へのp
	0x14 .. 次の構造体へのp
	0x18 .. 自分自身のポインタ
	0x1c .. 特有関数を呼ぶためのecx. 登録時の関数でnewされたひとっぽい。
}


################################################################################
自機データについて
###############################################################################

X軸 .. (136 〜  464)  ( 4308　〜 43e8) までの値を動く

自機位置の更新は sub_42F190 で行われる。
まず、loc_42F330 までのif文でキー入力を0〜7の8方向に判定した後、
loc_42F64D までに、だいたいの加える量を決定する。
詳しいことは解析してるので。

{ sub_42f190
	自機のデータアップデートっぽい。
	var11c .. ecx. 自機についての関数を呼ぶときのecxぽい。
	var11c .. ecx  aka. 4be3c8からenumされたあれ。
	自機位置 .. ecx+1e30
	
	ecx+2d4h .. なんかのswitchの判断に使われる。
	ecx+2a18 .. ふつう1,毒霧とかのときに0.25とかになる。
	
	word_4be244 .. キー入力の状態が入りそう。X : 1 , Z : 2 , shift : 5
	{ 42f900ころ
		
		4bded8 .. 動いてるかどうかの判定っぽい。(1 or 0。)。画面が止まったら0.

		動く速度は、ebp+var8(yza) とかvarc(xza)とかにstpされる。
		*(ecx +2a18h) と multされて。
		
		(1が押されてるなら低速。)
		*(ecx+410h)+18h or +20h(naname) (低速), か *(ecx+410h)+14h or +1ch (naname)
		さらに低速なら、*0.22 される。(2も押されてるとき)
		
		var128 .. &myx. ecx+1e30h; で、
		myxy += *(ecx+3fchのpos)
	}

	{ 42fa62からころ
		cor0 := var2c .. 
		a8, a4, a0 が左上のほうのに。
		で、左上 .. *varac - *varb0 みたいなposが入る。
		つまり、*(ecx+1e30)-*(ecx+3d8)
		38 34 30 が右下のほうのに。
		で、右下 .. *varc0 - *varc4 みたいなposが入る。
		つまり、*(ecx+1e30)+*(ecx+3d8)
		
		はい、自機のあたり判定の大きさは、
		*(ecx+3d8) に入ってますね。
	}
}

自機の充填率 
41d257
41d263
26f
432555

ecx + 0b80h
-> oecx + 1e3ch
+0x0 の 430180

################################################################################
敵機データについて
###############################################################################


敵の移動xは、 416175 で。(謎if文が入ってる)
//415970 , 416290 .. zimei

//または、412fce , 412fd7　かなんだなあ。 こちらは謎。
//408e70(やばいやつ) , 415b42 -> ここで合流。毎回呼ばれてる。

//2930 と 293c の和らしー。が、どっちになるんですかねー。
自xは+28b8h , y は 28bch

################################################################################
敵弾データについて
###############################################################################

{ 0x405508 ころ
	ecx .. +4ch のなにか。 ecx -> *(ecx+65ch) で回される。
	毎回初期化的なのも走ってるっぽい。
	4bded8 .. 動いてるかどうかの判定っぽい。(1 or 0。)
	myxza += var2c aka. var78
	myyza += var28 aka. var74
	また、 2dch .. なんか、速度っぽい。
	[8] += 動いてるか * 2dchの[8] とかで。
	[4] += 動いてるか * 2dchの[4] とかで。
	
	で、速度は var80 aka. var4+2dch で、 var4 は、いつもの、弾の。
}


################################################################################
表示について
###############################################################################

sub_4186D0 で、画面表示用の座標に変換している。 (edxの値を変換したものをecxに登録している)



################################################################################
弾と自機との衝突判定
###############################################################################
sub_430450 で行われている。
正方形と正方形の衝突判定がされてる。

{ sub_430450
  arg0 .. 弾 or 敵機の中心の位置
  arg4 .. 弾のあたり判定のbox ()
  +3a8 , +3ac , +3b4 , +3b8  が自機のあたり判定の四角形の四隅のよう。
}


対弾(40556b) or 対敵(415fe4). からの呼び出し
{ sub_430450
	arg0 .. +0がx,+4がy,まあposのポインタ。(弾の位置) bp.
	弾の場合は、 40556b での呼び出しでチェックぽい。
	arg4 .. pos. 自機の位置っぽい。myp
	var18 := myx/2 - bx
	var14 := myy/2 - by
	varc := myx/2 + bx
	var8 := myy/2 + by
	逆ですねー。
	で、それぞれ ecx (4c4e70)に対してなにか調べていて、
	+3a8 , +3ac , +3b4 , +3b8 と比べている。
	また、*(ecx) が 2 or 3 なら死なない。
}

対弾の場合、30chが弾のあたり判定の大きさみたい。
で、弾の中心は2d0h。 いつもの。

corn .. 4304b2 で。-> チェック場所の。
書き .. 42faf7 で。

################################################################################
レーザーの出力について
###############################################################################
停止時にも呼び出される->おそらく描画のため、
で、sub_4186d0 内で、 edx としてレーザーのpが呼ばれる。
で、ecx側に描画のが入る。
さて、 x側、 + 128.0 +192.0  , y側、 +16.0 ですね。

逆に、仮に、出力時には毎回 sub_4186d0 がかまされるのなら、
x += 128.0 + 192.0 と y += 16.0 はconst,定数と言えるのではないか。

で、ちな、表示は、at 4186e1(edxを表示分ずらすやつ) で、 
called from 0x41f9ab で、 ずれは、 [ecx+1e0h]分。か？

################################################################################
レーザーのアップデートについて
###############################################################################
sub_41F550内で行われてる。


{ sub_41F550
  ecx .. var_58 にためられる。レーザー構造体の情報。
  ecx+0ch .. レーザーの状態っぽい。(レーザーの移動時に触れられる)
  
  ecx+1ch .. レーザー位置(pos)
  ecx+1eh .. レーザー位置(pos) (これは固定みたい)
  
  ecx+34h .. レーザー角
  ecx+38h .. レーザの長さ方向あたり判定
  ecx+3ch .. レーザの幅方向あたり判定
  
  ecx+28h .. レーザー位置の移動速度
  ecx+6ch .. レーザー角の移動速度
}


[ecx+34h]のwrite .. 41f5c5 (角度のずれ)
{ loc_41F5A3:
	mov     ecx, [ebp+var_58]
	fld     dword_4BDED8
	fmul    dword ptr [ecx+6Ch]
	push    ecx //ん〜
	fstp    [esp+64h+var_64] ; float  //あっ！！はい。
	
	mov     edx, [ebp+var_58]
	mov     eax, [edx+34h]
	push    eax             ; float
	call    sub_41B500  // push (arg1 + arg2) -pi<<piに正規化する
	mov     ecx, [ebp+var_58]
	fstp    dword ptr [ecx+34h]
}
で、
[dword_4BDED8] * [ecx+6Ch] 分ずれていく。


[ecx+1ch] への変化
{ loc_41F609: あたり
	(var24,var20,var1c) = [dword_4BDED8] * (ecx + 5c)(8,4,0)
	(x,y,z) += (var24,var20,var1c)
}

で、dword_4BDED8!=0なら、*(ecx + 5ch)を足す、で。

いや、41e38B説が有力っぽい。
とすると、+28hっぽそうかな。
+28hですねー。


[ecx+38h] への変化
{ 関数冒頭あたりのみ。
  70hと比べてなにかなら、飛ばされる、もしくは[ecx+70h]のほうにされるっぽい。
  そうでないとき、[dword_4BDED8] * [ecx+40h] 分ずれる。
}



ビームの移動(41f550)は、 called from 41d9f3 で、pushed in 418a20


################################################################################
レーザーと自機との衝突判定
###############################################################################
sub_430530 で行われている。


ビームについて、なんか、見えますぜ。
push4つで判定してますなぁ。(41e5faにて)
float float float int.

[arg0のpos] - [this+1e30のpos]　が回すやつの座標で、
[this + 3d8h] を nazop とすると、(実はあたり判定の大きさ)

nazopはあたり判定の大きさ(1/2されたやつか. 1.0と1.0)
回すやつ,の[this+1e30のpos] は自機座標ですね。
arg0はレーザーの位置と連動してるっぽい。
で、回すやつ、は、自機からのレーザーの相対座標。

	if(回したtx < -argc){
		if(回したtx <= 0){
			if(-arg8/2 >= 回したty){
				if(-arg8/2 >  回したty){ //あれっ...
					colision!!();
				}
			}
		}
	}


if(argc + 回したtx < nazop.x  <= -回したtx){ //argcはx方向のあたり判定
	if(arg8/2 + 回したty <= nazop.y < -(arg8/2 + 回したty)){ //逆っぽいぞ... //arg8はy方向のあたり判定
		colision!!();
	}
}


loc_4306ae にはいるとビームで死亡なので、逆に
loc_4306ae にブレークポイントを仕掛けると
デバッグがわりになる。

で、this は、 dword_4C4E70　からとられてる。


さて、
毎回、41e626側から呼ばれてる。
{ loc_41E559 あたり
  ecx は、 ebp+var_68 に入ってる
  :loc_41e587
  [ebp_var18] = fpos(sin([ecx+34h])*8.0,cos([ecx+34h])*8.0)
  [ebp_var18] = [ebp_var18] + [ecx + 1ch]
  if([ecx+3ch] < 32.0)[var74] = [ecx+3ch] / 2;
  else [var74] = [ecx+3ch] - 16.0;
  call判定(pos=var18,theta=ecx+34h,dx=var74,dy=38h-16);
}

{
	さて、arg0 .. レーザー位置の構造体のp
		  arg4 .. あたり判定の角度
	      arg8 .. xのずれ argc .. yのずれ、で。

	arg0 .. rad2xy([ecx+34h],8) + [ecx+1ch]posで。
	arg4 .. [ecx+34h]
	arg8 .. [ecx+3ch] を32と比べて, 小さいなら*0.5,大きいなら-16 で。
	argc .. [ecx+38h]-16.0 で。

	arg0 .. var18 arg4 .. [ecx+
	arg8 .. var74 , argc .. [var68+38h]-16.0 で。
	var68 .. ecx, 
	var74 .. [var68+3ch] を32と比べて, 小さいなら*0.5,大きいなら-16 で。
	var18 .. rad2xy([ecx+34h],8) + [ecx+1ch]posで。


	で、 41e2c0　は、 called from 0x41d9f3 で、
	ecx は、 ebp+var4 で、この関数内で、
	var4 -> [var4+8] 回しで。
	var4 =[ecx+8] で。
	このecxは、418a20のほうのから、func==sub_41db00のときのecxで得られる。
}


###################################################################################################################################
構造体について
###################################################################################################################################

*0x4ca1b8{
	0x42034c で initされてる。
	大きさ 0x38314c (おかしいやろ)
	コンストラクタは sub_441dc0
	unknown_libname_82 ; Microsoft VisualC 2-11/net runtimeがあるのでコンストラクタっぽい。

	0x421c90 とかがthisとして。
};

*0x4c4e74*{
	リプレイのためのデータを保存する構造体。
	0x20 .. ミニ構造体。{
		0x428cae , 0x42927cで、
		0x10 ..   timer()の値を格納される。(現在のリプレイ保存のため)
		0x14 .. point. 0x4bdec8 の 0x114 の値が入る。
	}
};

*0x4be3c8{
	0x42a6e0,からの0x429c80 の thisポインタの人。
	リプレイ画面を表示する程度の能力。
	0x6ce8 .. 構造体20個へのポインタ。{
		0x20{
			0x2 .. level数
			0x3 .. シーン数。
			0x7 .. リプレイデータのタイトル
			0x10 .. 時間も含めた日付情報
			0x14 .. point数 
			//どっかで見た構造体。
		}
	}
}

*0x4ca2f0{ //多分、現在のリプレイ情報登録のためのデータが入ってる。
	0x4 .. level
	0x8 .. scene
}

*0x4bdec8{ //ショットとかの情報も入るっぽい。
	0x100 .. 全体からみたときのステージの番号
	0x114 .. point
}

0x42a6e0*{ //エスケープ時の画面のデータが得られる。
	sub_429c80 //replay保存画面を表示するための関数っぽい...
	0x4 .. replay画面のstate. switch用
	0x6d3c .. 入れ掛けの文字情報とかが得られるらしい。
	0x6d48 .. 何枚目の写真を写してるか。(成功時のアレのとき)
	0x6e20 .. bestshot was overwritten
}

*0x4c4e6c{
	0x21f4 + i * 0x2214 .. i番目のshot の point が得られる (たかだか11枚っぽい)
}

*0x4c4e78{
	0x470 + i * 0x60 .. i 番目のステージのハイスコア
	0x4a8 + i * 0x60 .. i番目のステージのスローレート、的な。
	//stage0 から stage 0x78 まであるっぽい。
}

###################################################################################################################################
関数について
###################################################################################################################################


sub_4190b0 .. コンストラクタ

sub_4255b0 .. 排他制御にするやつ、かな。
func(PFUN,classpointer) みたいにつかいそう。

sub_0x417d20 .. 0x4c4670 の、多分排他制御とかついてる、メゾッド。
中で0x417A70 (いろんなデータの.anmの初期化(コンストラクタ的なの))をしてる。


sub_429c80 .. replay画面ぽい。いや、プレイ時には入るっぽい。

sub_452630 .. ステージセレクト画面を表示するための関数っぽい。 (いや、起動すれば常時入るっぽい...)
loc_4526a6内は、ステージセレクト画面に対応してる。

45273dでpushされるのが、今表示してるステージのスコア。

4c4e78 + ecx + 470hがステージのスコア。
おそらく、ステージは、大きさ0x60刻みの構造体。
[var94hのecx+0BF0]にステージ番号が入ってる。
//loc_452721あたり
で、var94hはecxで、
sub_445E60のecxで、
sub_4190B0(描画)のほうでタスクシステムに登録されてる。


sub_4306d0 .. 脂肪判定。ここに入ると即刻auto.(成功した場合は入らない。)

sub_429c80 .. プレイ中はここに入る。

loc_429d49 .. 撮影成功画面においてのみ、ここに入る(失敗時には入らない)

loc_42a0d8 .. 保存するreplay番号を選ぶときに入る。

jmp     ds:off_42A68D[ecx*4] ; switch jump の429d1bにおいて... 
休止時選択画面で入る。ecxについて、
通常脂肪は0,リプレイ#選択は2, いや、
429cf2のecxにおいて、
リプレイ再生時は0,リプレイ一時停止時はb,
ゲーム時は0,被弾後死亡時は3,被弾後リプレイ#選択時はd,
一時停止時は1,撮影成功時は5,成功後後リプレイ#選択時はd,保存名選択時はe
とかなる。
停止からの再開時に2とか,再挑戦時に4とか。
終了時には読めなくなってるっぽい。(read errorになる)

右下が正。

